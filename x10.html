<!DOCTYPE html>
<html class="split chapter"><head>
<!-- Inserted by TRADOS: -->
<meta charset="utf-8"><title>10 Исполняемый код и контексты исполнения | ES5 на русском</title><link rel="stylesheet" href="style.css"><link href="x9.html" title="9 Преобразование и проверка типов " rel="prev">
  <link href="index.html" title="Содержание" rel="index">
  <link href="x11.html" title="11 Выражения " rel="next">
  </head><body><div class="head">
<h2 id="top">Спецификация ECMAScript 5.1 с аннотациями <span id="timestamp"></span></h2>
<!--left..-->
<div id="slogan">
  <div id="share-toggler">Поделиться</div>
  <div class="share">
  <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://es5.javascript.ru/" data-lang="ru" data-size="large" data-count="horizontal">Твитнуть</a>
  <div id="fb-root"></div>
  <div style="margin-bottom:5px" class="fb-like" data-href="http://es5.javascript.ru" data-send="false" data-action="recommend" data-layout="button_count" data-width="300" data-show-faces="false" data-font="arial"></div>
  <div class="vk-share-wrapper">
  <script src="http://vkontakte.ru/js/api/share.js?9" charset="windows-1251"></script>  
  <script src="misc.js"></script>
  </div>

  <div style="margin-top:6px">
  <g:plusone annotation="inline" href="http://es5.javascript.ru/" width="120" size="standard" style="vertical-align:middle"></g:plusone>
  </div>
  </div>
</div>
<!--..left-->

<div id="annotations">



</div>
</div>
<nav>
   <a href="x9.html">&#8592; 9 Преобразование и проверка типов </a> &#8211;
   <a href="index.html" class="toc-nav">Содержание</a> &#8211;
   <a href="x11.html">11 Выражения  &#8594;</a>
  <ol class="toc"><li><a href="x10.html#x10" id="x10-toc">10 Исполняемый код и контексты исполнения</a>
    <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> <ol><li><a href="x10.html#x10.1" id="x10.1-toc">10.1 Типы исполняемого кода</a>
        <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> <ol><li><a href="x10.html#x10.1.1" id="x10.1.1-toc">10.1.1 Код в строгом режиме</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li></ol></li><li><a href="x10.html#x10.2" id="x10.2-toc">10.2 Лексические Окружения</a>
        <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> <ol><li><a href="x10.html#x10.2.1" id="x10.2.1-toc">10.2.1 Записи окружений</a>
            <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> <ol><li><a href="x10.html#x10.2.1.1" id="x10.2.1.1-toc">10.2.1.1 Декларативные записи окружений</a>
                <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> <ol><li><a href="x10.html#x10.2.1.1.1" id="x10.2.1.1.1-toc">10.2.1.1.1 HasBinding(N)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.1.1.2" id="x10.2.1.1.2-toc">10.2.1.1.2 CreateMutableBinding (N, D)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.1.1.3" id="x10.2.1.1.3-toc">10.2.1.1.3 SetMutableBinding (N,V,S)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.1.1.4" id="x10.2.1.1.4-toc">10.2.1.1.4 GetBindingValue(N,S)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.1.1.5" id="x10.2.1.1.5-toc">10.2.1.1.5 DeleteBinding (N)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.1.1.6" id="x10.2.1.1.6-toc">10.2.1.1.6 ImplicitThisValue()</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.1.1.7" id="x10.2.1.1.7-toc">10.2.1.1.7 CreateImmutableBinding (N)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.1.1.8" id="x10.2.1.1.8-toc">10.2.1.1.8 InitializeImmutableBinding (N,V)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li></ol></li><li><a href="x10.html#x10.2.1.2" id="x10.2.1.2-toc">10.2.1.2 Объектные записи окружений</a>
                <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> <ol><li><a href="x10.html#x10.2.1.2.1" id="x10.2.1.2.1-toc">10.2.1.2.1 HasBinding(N)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.1.2.2" id="x10.2.1.2.2-toc">10.2.1.2.2 CreateMutableBinding (N, D)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.1.2.3" id="x10.2.1.2.3-toc">10.2.1.2.3 SetMutableBinding (N,V,S)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.1.2.4" id="x10.2.1.2.4-toc">10.2.1.2.4 GetBindingValue(N,S)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.1.2.5" id="x10.2.1.2.5-toc">10.2.1.2.5 DeleteBinding (N)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.1.2.6" id="x10.2.1.2.6-toc">10.2.1.2.6 ImplicitThisValue()</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li></ol></li></ol></li><li><a href="x10.html#x10.2.2" id="x10.2.2-toc">10.2.2 Операции Лексического Окружения</a>
            <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> <ol><li><a href="x10.html#x10.2.2.1" id="x10.2.2.1-toc">10.2.2.1 GetIdentifierReference (lex, name, strict)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.2.2" id="x10.2.2.2-toc">10.2.2.2 NewDeclarativeEnvironment (E)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.2.2.3" id="x10.2.2.3-toc">10.2.2.3 NewObjectEnvironment (O, E)</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li></ol></li><li><a href="x10.html#x10.2.3" id="x10.2.3-toc">10.2.3 Глобальное окружениеt</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li></ol></li><li><a href="x10.html#x10.3" id="x10.3-toc">10.3 Контексты исполнения</a>
        <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> <ol><li><a href="x10.html#x10.3.1" id="x10.3.1-toc">10.3.1 Разрешение идентификатора</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li></ol></li><li><a href="x10.html#x10.4" id="x10.4-toc">10.4 Установление контекста исполнения</a>
        <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> <ol><li><a href="x10.html#x10.4.1" id="x10.4.1-toc">10.4.1 Вход в глобальный код</a>
            <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> <ol><li><a href="x10.html#x10.4.1.1" id="x10.4.1.1-toc">10.4.1.1 Исходный глобальный контекст исполнения</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li></ol></li><li><a href="x10.html#x10.4.2" id="x10.4.2-toc">10.4.2 Вход в eval-код</a>
            <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> <ol><li><a href="x10.html#x10.4.2.1" id="x10.4.2.1-toc">10.4.2.1 Ограничения строгого режима</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li></ol></li><li><a href="x10.html#x10.4.3" id="x10.4.3-toc">10.4.3 Вход в код функции</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li></ol></li><li><a href="x10.html#x10.5" id="x10.5-toc">10.5 Инстанциирование привязки объявления</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li><li><a href="x10.html#x10.6" id="x10.6-toc">10.6 Объект аргументов</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b> </li></ol></li></ol></nav>

  <h2 id="x10">10 Исполняемый код и контексты исполнения <a href="#x10">#</a> <a href="#x10-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h2>
	<h3 id="x10.1">10.1 Типы исполняемого кода <a href="#x10.1">#</a> <a href="#x10.1-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h3>
	<p>
	Существует три типа исполняемого кода ECMAScript:</p>
	<ul><li><p><dfn id="global-code"><i>Глобальный код</i></dfn> представляет собой исходный текст, обрабатываемый как <i><a href="x14.html#x14">Программа</a></i> <em>Program</em> на ECMAScript. Глобальный код какой-либо конкретной <i><a href="x14.html#x14">Программы</a></i> не включает в себя исходный текст, распознаваемый как часть <i><a href="x13.html#x13">FunctionBody</a></i> <tt>Тело функции</tt>.</p>
		</li>
		<li><p><dfn id="eval-code"><i>Eval-код</i></dfn> представляет собой исходный текст, передаваемый во встроенную функцию  <code><b><a href="x15.1.html#x15.1.2.1">eval</a></b></code>. Точнее &ndash; если параметром, передаваемым во встроенную функцию <code><b><a href="x15.1.html#x15.1.2.1">eval</a></b></code>, является строка, она обрабатывается как <i><a href="x14.html#x14">Программа</a></i> на ECMAScript. Eval-код для какого-либо конкретного вызова функции <code><b>eval</b></code> представляет собой часть <a href="#global-code">глобального кода</a> этой <i><a href="x14.html#x14">Программы</a></i>.</p>
		</li>
		<li><p><dfn id="function-code"><i>Код функции</i></dfn> &ndash; это исходный текст, получаемый в результате синтаксического разбора <i><a href="x13.html#x13">Тела функции</a></i>. Код функции для конкретного <i><a href="x13.html#x13">Тела функции</a></i> не включает в себя исходный текст, полученный в процессе синтаксического разбора вложенных <i><a href="x13.html#x13">Тел функции</a></i>. Кроме того, <i>Код функции</i> означает исходный текст, передаваемый при <a href="x15.3.html#x15.3.2" class="term-ref">использовании встроенного объекта <code><b>Function</b></code> как конструктора</a>. Точнее &ndash; последний параметр, передаваемый в конструктор <code><b>Function</b></code>, преобразуется в строку и обрабатывается как <i><a href="x13.html#x13">Тело функции</a></i>. Если в конструктор <code><b>Function</b></code> передается несколько параметров, то все они, кроме последнего, преобразуются в строки и конкатенируются, при этом они разделяются запятыми. Образовавшаяся в результате строка интерпретируется как <I>FormalParameterList </I> <tt>Список формальных параметров</tt> для <i><a href="x13.html#x13">Тела функции</a></i>, определяемого последним параметром. Код функции для создания такого объекта <code><b>Function</b></code> не включает в себя исходный текст, читаемый в процессе синтаксического разбора вложенного <i><a href="x13.html#x13">Тела функции</a></i>.</p>
	
	</li></ul>
	<h4 id="x10.1.1">10.1.1 Код в строгом режиме <a href="#x10.1.1">#</a> <a href="#x10.1.1-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>
	<p>
	Синтаксическая единица <i><a href="x14.html#x14">Программы</a></i> на ECMAScript  может обрабатываться с использованием синтаксиса и семантики либо в неограниченном <em>unrestricted</em>, либо в строгом <em>strict</em> режиме. При обработки синтаксической единицы с использованием строгого режима упомянутые три типа кода ECMAScript называются строгим глобальным кодом, строгим eval-кодом и строгим кодом функции. Код считается <a href="#x10.1.1" class="term-ref">кодом в строгом режиме</a> в следующих случаях:</p>
	<ul><li><p>
	 <a href="#global-code">Глобальный код</a> является глобальным кодом в строгом режиме, если он начинается с Директивного пролога, содержащего директиву &quot;Use Strict&quot; (&quot;Использовать строгий&quot;) &ndash; (см.&nbsp;пункт&nbsp;<a href="x14.html#x14.1">14.1</a>).</p>
		</li>
		<li><p>
	 <a href="#eval-code">Eval-код</a> является eval-кодом в строгом режиме, если он начинается с Директивного пролога, содержащего директиву &quot;Use Strict&quot;, или если вызов eval является прямым вызовом (см.&nbsp;пункт&nbsp;<a href="x15.1.html#x15.1.2.1.1">15.1.2.1.1</a>) <a href="x15.1.html#x15.1.2.1">функции eval</a>, которая содержится в <a href="#x10.1.1" class="term-ref">коде в строгом режиме</a>.
		</p>
		</li>
		<li><p>
	 <a href="#function-code">Код функции</a>, который является частью <i><a href="x13.html#x13">FunctionDeclaration</a></i> <tt>Объявление функции</tt>, <i><a href="x13.html#x13">FunctionExpression</a></i> <tt>Выражение функции</tt> или <i>PropertyAssignment</i> <tt>Присваивание свойства</tt> аксессора, является кодом функции в строгом режиме, если его <i><a href="x13.html#x13"><I>Объявление функции</I></a></i>, <i><a href="x13.html#x13"><I>Выражение функции</I></a></i> или <I>Присваивание свойства</I> содержатся в <a href="#x10.1.1" class="term-ref">коде в строгом режиме</a>, или если этот код функции начинается с Директивного пролога, содержащего директиву &quot;Use Strict&quot;.</p>
		</li>
		<li><p>
	 <a href="#function-code">Код функции</a>, передаваемый во встроенный конструктор функции в качестве последнего аргумента, является кодом в строгом режиме, если этот последний аргумент представляет собой строку, которая при её обработке в качестве <i><a href="x13.html#x13">Тела функции</a></i> начинается с Директивного пролога, содержащего директиву &quot;Use Strict&quot;.</p>
	</li></ul>
	<h3 id="x10.2">10.2 Лексическое Окружение <a href="#x10.2">#</a> <a href="#x10.2-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h3>
	<p>
	<i>Lexical Environment</i> <tt>Лексическое Окружение</tt> &ndash; это <a href="x8.html#specification-type">тип спецификации</a>, который используется для определения связи между <I>Identifiers</I> <tt>Идентификаторами</tt> и отдельными переменными и функциями, на основе структуры лексической вложенности кода на ECMAScript. Лексическое Окружение состоит из <a href="#x10.2.1">Записи Окружения</a> и возможной ссылки null на <i>внешнее</i> Лексическое Окружение. Обычно Лексическое Окружение ассоциируется с определёнными синтаксическими структурами кода на ECMAScript, такими как <i><a href="x13.html#x13">FunctionDeclaration</a></i>, <I>WithStatement</I> <tt>Инструкция With</tt> или выражение <i>Catch </i>в <I>TryStatement</I> <tt>Инструкция Try</tt>, при этом каждый раз при обработке кода создаётся новое Лексическое Окружение.</p>
	<p>
	<a href="#x10.2.1"><i>Запись Окружения</i></a> содержит привязки идентификатора, создаваемые в рамках ассоциированного с ним Лексического Окружения.</p>
	<p>
	Для моделирования логической вложенности Лексических Окружений используется "внешняя ссылка окружения". Внешней ссылкой (внутреннего) Лексического Окружения является ссылка на Лексическое Окружение, которое логически окружает это внутреннее Лексическое Окружение. Конечно же, у внешнего Лексического Окружения может быть, в свою очередь, собственное внешнее Лексическое Окружение. Одно Лексическое Окружение может являться внешним окружением для нескольких внутренних Лексических Окружений. Например, если <i><a href="x13.html#x13">FunctionDeclaration</a></i> содержит два вложенных <I>FunctionDeclaration</I>, то Лексическое Окружение текущего исполнения окружающей функции будет являться внешним Лексическим Окружением для Лексических Окружений каждой из вложенных функций.</p>
	<p>
	Лексические Окружения и значения Записи Окружения являются исключительно механизмами спецификации; они не должны соответствовать каким-либо конкретным артефактам реализации ECMAScript. Программа на ECMAScript не может осуществлять прямого доступа к таким значениям или манипулировать ими напрямую.</p>
	<h4 id="x10.2.1">10.2.1 Записи окружений <a href="#x10.2.1">#</a> <a href="#x10.2.1-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>
	<p>
	В данной спецификации используется два вида значений Записей Окружения: <I>декларативные записи окружения</I> <em><i>declarative environment records</i></em> и <I>объектные записи окружения</I> <em><i>object environment records</i></em>.  <dfn id="declarative-environment-record">Декларативные записи окружения</dfn> используются, чтобы определить действие таких синтаксических элементов языка ECMAScript, как <i>FunctionDeclaration</i>, <i>VariableDeclaration</i> и выражения <i>Catch</i>, которые напрямую ассоциируют привязки <b>идентификатора</b> со значениями языка ECMAScript.
	<dfn id="object-environment-record">Объектные записи окружения</dfn> используются для определения действия таких элементов ECMAScript, как <a href="x14.html#x14"><i>Program</i></a> и <i>WithStatement</i>, которые ассоциируют привязки <b>идентификатора</b> со свойствами некоторого объекта.</p>
	<p>
	Для целей спецификации значения Записи Окружения можно рассматривать как существующие в простой объектно-ориентированной иерархии, где Environment Record представляет собой абстрактный класс с двумя конкретными подклассами: декларативной записью окружения и объектной записью окружения. Этот абстрактный класс включает абстрактные методы спецификации, определённые в Таблице&nbsp;17. Для этих абстрактных методов имеются конкретные алгоритмы в каждом из конкретных подклассов.
	</p>
	<center>
		<table width="690" border="1" bordercolor="#000000" cellpadding="8" cellspacing="0" rules="ROWS"><caption>Таблица 17. Абстрактные методы записей окружения</caption>
			<colgroup><col width="211"><col width="445"></colgroup><tbody><tr valign="TOP"><td width="211" height="11" bgcolor="#c0c0c0">
					<p>
					<i><b><span class="table-header">Метод</span></b></i></p>
				</td>
				<td width="445" bgcolor="#c0c0c0">
					<p>
					<i><b><span class="table-header">Назначение</span></b></i></p>
				</td>
			</tr><tr valign="TOP"><td width="211">
					<p>
					HasBinding(N)</p>
				</td>
				<td width="445">
					<p>
					Определяет, имеет ли запись окружения привязку к идентификатору. Возвращает <b>true</b>, если имеет, и <b>false</b>, если не имеет. Текстом идентификатора является строковое значение <i>N</i> .</p>
				</td>
			</tr><tr valign="TOP"><td width="211" height="43">
					<p>
					CreateMutableBinding(N, D)</p>
				</td>
				<td width="445">
					<p>
					Создаёт в записи окружения новую изменяемую привязку. Строковое значение <i>N</i> будет привязанным именем. Если необязательный булевый аргумент <i>D</i> &ndash; <b>true</b>, то привязка может быть впоследствии удалена.
					</p>
				</td>
			</tr><tr valign="TOP"><td width="211" height="76">
					<p>
					SetMutableBinding(N,V, S)</p>
				</td>
				<td width="445">
					<p>
					Присваивает значение уже существующей в записи окружения изменяемой привязки. Строковое значение <i>N</i> будет привязанным именем. <i>V</i> является значением привязки; оно может быть значением любого <a href="x8.html#language-type">языкового типа</a> ECMAScript. <i>S</i> &ndash; булев флаг. Еcли <i>S</i> &ndash; <b>true</b>, и привязка не может быть установлена, то сгенерировать исключение <b><a href="x15.11.html#x15.11.6.5" class="term-ref">TypeError</a></b>. <i>S</i> используется для обозначения ссылок в строгом режиме.</p>
				</td>
			</tr><tr valign="TOP"><td width="211">
					<p>
					GetBindingValue(N,S)</p>
				</td>
				<td width="445">
					<p>
					Возвращает из записи окружения значение уже существующей привязки. Текстом связанного имени является строковое значение <i>N</i>. <i>S</i> используется для обозначения ссылок в строгом режиме. Ели <i>S</i> &ndash; <b>true</b>, и привязки не существует или привязка не инициализирована, сгенерировать исключение <b><a href="x15.11.html#x15.11.6.3" class="term-ref">TypeError</a></b>.
					</p>
				</td>
			</tr><tr valign="TOP"><td width="211" height="58">
					<p>
					DeleteBinding(N)</p>
				</td>
				<td width="445">
					<p>
					Удаляет привязку из записи окружения. Текстом связанного имени является строковое значение <i>N</i>. Если привязка для <i>N</i> существует, удалить привязку и вернуть <b>true</b>. Если привязка существует, но не может быть удалена, то вернуть <b>false</b>. Если привязки не существует, то вернуть <b>true</b>.</p>
				</td>
			</tr><tr valign="TOP"><td width="211">
					<p>ImplicitThisValue()</p>
				</td>
				<td width="445">
					<p>Возвращает значение, которое будет использоваться в качестве значения <b>this</b> при вызовах объектов функции, получаемых в качестве значений привязки из этой записи окружения.
					</p>
				</td>
			</tr></tbody></table></center>
	<h5 id="x10.2.1.1">10.2.1.1 Декларативные записи окружения <a href="#x10.2.1.1">#</a> <a href="#x10.2.1.1-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h5>
	<p>
	Каждая декларативная запись окружения ассоциирована областью видимости программы на ECMAScript, которая содержит объявления переменных и/или объявления функций. Декларативная запись окружения содержит привязки для идентификаторов, определённых в рамках её области видимости.</p>
	<p class="sm-btm">
	В дополнение к изменяемым привязкам, которые поддерживаются всеми записями окружения, декларативные записи окружения предусматривают и неизменяемые привязки.  <dfn id="immutable-binding">Неизменяемая привязка</dfn> &ndash; это привязка, в которой связь, установленная между идентификатором и значением, уже не может быть изменена. Создание и инициализация неизменяемых привязок представляют собой отдельные шаги, поэтому такие привязки вполне могут существовать как в инициализированном, так и в неинициализированном виде. Кроме абстрактных методов спецификации записи окружения, декларативные записи окружения поддерживают методы, перечисленные в Таблице&nbsp;18:</p>
	<center>
		<table width="698" border="1" bordercolor="#000000" cellpadding="8" cellspacing="0" rules="ROWS"><caption>Таблица 18. Дополнительные методы декларативных записей окружения</caption>
			<colgroup><col width="219"><col width="445"></colgroup><tbody><tr valign="TOP"><td width="219" height="8" bgcolor="#c0c0c0">
					<p>
					<i><b><span class="table-header">Метод</span></b></i></p>
				</td>
				<td width="445" bgcolor="#c0c0c0">
					<p>
					<i><b><span class="table-header">Назначение</span></b></i></p>
				</td>
			</tr><tr valign="TOP"><td width="219">
					<p>
					<a href="#x10.2.1.1.7">CreateImmutableBinding</a>(N)</p>
				</td>
				<td width="445">
					<p>
					Создаёт в записи окружения новую, но не инициализированную <a href="#immutable-binding">неизменяемую привязку</a>. Текстом связанного имени является строковое значение <I>N</I>.</p>
				</td>
			</tr><tr valign="TOP"><td width="219">
					<p><a href="#x10.2.1.1.8">InitializeImmutableBinding</a>(N,V)</p>
				</td>
				<td width="445">
					<p>Присваивает значение уже существующей в записи окружения, но не инициализированной <a href="#immutable-binding">неизменяемой привязки</a>. Строковое значение <I>N</I> будет именем. <i>V</i> будет значением любого <a href="x8.html#language-type">языкового типа</a> ECMAScript.
					</p>
				</td>
			</tr></tbody></table></center>
	<p>
	Поведение конкретных методов спецификации для Декларативных записей окружения определяется следующими алгоритмами:</p>
	<h6 id="x10.2.1.1.1">10.2.1.1.1 HasBinding(N) <a href="#x10.2.1.1.1">#</a> <a href="#x10.2.1.1.1-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>
	<p>
	Конкретный метод записи окружения HasBinding <tt>Имеет&nbsp;привязку</tt> для декларативных записей окружения просто определяет, является ли идентификатор аргумента одним из идентификаторов, связанных этой записью:</p>
	<ol><li><p>
		Пусть <i>envRec</i> &ndash; декларативная запись окружения, для которой вызывается этот метод.</p>
		</li>
		<li><p>
		Если <i>envRec</i> имеет привязку к имени, которое представляет собой значение&nbsp;<i>N</i>, вернуть <b>true</b>.</p>
		</li>
		<li><p>
		Если оно не имеет такой привязки, то вернуть&nbsp;<b>false.</b></p>
	</li></ol>
	<h6 id="x10.2.1.1.2">10.2.1.1.2 CreateMutableBinding (N, D) <a href="#x10.2.1.1.2">#</a> <a href="#x10.2.1.1.2-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>
	<p>
	Конкретный метод записи окружения CreateMutableBinding <tt>Создать изменяемую привязку</tt> для записей декларативного окружения создаёт для имени&nbsp;<i>N</i> новую изменяемую привязку, которая инициализируется с присвоением значения&nbsp;<b>undefined</b>.  До этого момента в этой записи окружения для <i>N</i> не должно существовать привязки. Если имеется булевый аргумент <i>D</i>, и при этом его значение &ndash; <b>true</b>, то эта новая привязка помечается как удаляемая.</p>
	<ol><li><p>
		Пусть <i>envRec </i> &ndash; декларативная запись окружения, для которой вызывается этот метод.</p>
		</li>
		<li><p>
		Утверждается: у <i>envRec</i> еще нет привязки для&nbsp;<i>N</i>.</p>
		</li>
		<li><p>
		Создать изменяемую привязку в <i>envRec</i> для <i>N</i> и установить её связанное значение как <b>undefined</b>. Если <i>D</i> &ndash; true, то записать, что эта новая привязка может быть удалена вызовом DeleteBinding.</p>
	</li></ol>
	<h6 id="x10.2.1.1.3">10.2.1.1.3 SetMutableBinding (N,V,S) <a href="#x10.2.1.1.3">#</a> <a href="#x10.2.1.1.3-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>


	<p>
	Конкретный метод записи окружения SetMutableBinding <tt>Установить значение изменяемой привязки</tt> для декларативных записей окружения пытается изменить связанное значение текущей привязки идентификатора, имя которого представляет собой значение аргумента&nbsp;<i>N</i>, на значение аргумента&nbsp;<i>V</i>. Привязка для&nbsp;<i>N</i> уже должна существовать. Если привязка является <a href="#immutable-binding">неизменяемой привязкой</a>, и при этом <i>S</i> &ndash; <b>true</b>, то будет сгенерировано исключение <b>TypeError</b>.
	</p>

	<ol><li><p>
		Пусть <i>envRec </i> &ndash; декларативная запись окружения, для которой вызывается этот метод.</p>
		</li>
		<li><p>
		Утверждается: у <i>envRec</i> уже должна быть привязка для&nbsp;<i>N</i>.</p>
		</li>
		<li><p>
		Если привязка для <i>N</i> в <i>envRec</i> является изменяемой привязкой, то изменить её связанное значение на&nbsp;<i>V</i>.</p>
		</li>
		<li><p>
		Иначе, это является попыткой изменить значение <a href="#immutable-binding">неизменяемой привязки</a>, поэтому, если <i>S</i> &ndash; <b>true</b>, то сгенерировать исключение <b><a href="x15.11.html#x15.11.6.5" class="term-ref">TypeError</a></b>.</p>
	</li>
</ol>
<h6 id="x10.2.1.1.4">10.2.1.1.4 GetBindingValue(N,S) <a href="#x10.2.1.1.4">#</a> <a href="#x10.2.1.1.4-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>
	<p>
	Конкретный метод записи окружения GetBindingValue <tt>Получить значение привязки</tt> для декларативных записей окружения просто возвращает значение его связанного идентификатора, имя которого представляет собой значение аргумента&nbsp;<i>N</i>. Эта привязка уже должна существовать. Если <i>S</i> &ndash; <b>true</b>, и привязка является неинициализированной <a href="#immutable-binding">неизменяемой привязкой</a>, то сгенирировать исключение <b><a href="x15.11.html#x15.11.6.3" class="term-ref">ReferenceError</a></b>.</p>
	<ol><li><p>
		Пусть <i>envRec </i> &ndash; декларативная запись окружения, для которой вызывается этот метод.</p>
		</li>
		<li><p>
		Утверждается: у <i>envRec</i> уже есть привязка для&nbsp;<i>N</i>.</p>
		</li>
		<li><p>
		Если привязка для <i>N</i> в записи окружения <i>envRec</i> является неинициализированной <a href="#immutable-binding">неизменяемой привязкой</a>, то</p>
		<ol><li><p>
			Если <i>S</i> &ndash; <b>false</b>, вернуть значение <b>undefined</b>, в противном случае сгенерировать исключение <b><a href="x15.11.html#x15.11.6.3" class="term-ref">ReferenceError</a></b>.</p>
		</li></ol></li>
		<li><p>
		Иначе, вернуть значение, в настоящее время привязанное к&nbsp;<i>N</i> в&nbsp;записи окружения&nbsp;<i>envRec</i>.</p>
	</li></ol>
	<h6 id="x10.2.1.1.5">10.2.1.1.5 DeleteBinding (N) <a href="#x10.2.1.1.5">#</a> <a href="#x10.2.1.1.5-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>
	<p>
	Конкретный метод записи окружения для декларативных записей окружения DeleteBinding <tt>Удалить привязку</tt> может удалять только те привязки, которые явно обозначены как удаляемые.</p>
	<ol><li><p>
		Пусть <i>envRec </i> &ndash; декларативная запись окружения, для которой вызывается этот метод.</p>
		</li>
		<li><p>
		Если <i>envRec</i> не имеет привязки к имени, которое является значением&nbsp;<i>N</i>, вернуть <b>true</b>.</p>
		</li>
		<li><p>
		Если привязка для&nbsp;<i>N</i> в&nbsp;<i>envRec</i> не может быть удалена, вернуть&nbsp;<b>false</b>.</p>
		</li>
		<li><p>
		Удалить привязку для <i>N</i> из&nbsp;<i>envRec</i>.</p>
		</li>
		<li><p>
		Вернуть <b>true</b>.</p>
	</li></ol>
	<h6 id="x10.2.1.1.6">10.2.1.1.6 ImplicitThisValue() <a href="#x10.2.1.1.6">#</a> <a href="#x10.2.1.1.6-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>
	<p>
	Декларативные записи окружения всегда возвращают значение <b>undefined</b> в качестве их ImplicitThisValue <tt>Явное значение This</tt>.</p>
	<ol><li><p>
		Вернуть <b>undefined</b>.</p>
	</li></ol>
	<h6 id="x10.2.1.1.7">10.2.1.1.7 CreateImmutableBinding (N) <a href="#x10.2.1.1.7">#</a> <a href="#x10.2.1.1.7-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>
	<p>
	Конкретный метод записи окружения CreateImmutableBinding <tt>Создать неизменяемую привязку</tt> для записей декларативного окружения создаёт для имени&nbsp;<I>N </I>новую <a href="#immutable-binding">неизменяемую привязку</a>, которая инициализируется с присвоением значения <b>undefined</b>.  До этого момента в этой записи окружения для <i>N</i> не должно существовать привязки.</p>
	<ol><li><p>
		Пусть <i>envRec </i> &ndash; декларативная запись окружения, для которой вызывается этот метод.</p>
		</li>
		<li><p>
		Утверждается: у <i>envRec</i> еще нет привязки для&nbsp;<i>N</i>.</p>
		</li>
		<li><p>
		Создать в&nbsp;<i>envRec</i> для&nbsp;<i>N</i> <a href="#immutable-binding">неизеняемую привязку</a> и записать, что она является неинициализированной.</p>
	</li></ol>
	<h6 id="x10.2.1.1.8">10.2.1.1.8 InitializeImmutableBinding (N,V) <a href="#x10.2.1.1.8">#</a> <a href="#x10.2.1.1.8-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>
	<p>
	Конкретный метод записи окружения InitializeImmutableBinding <tt>Инициализировать неизменяемую привязку</tt> для декларативных записей окружения используется для присвоения значения аргумента&nbsp;<i>V</i> связанному значению текущей привязки идентификатора, имя которого &ndash; значение аргумента&nbsp;<i>N</i>. Неинициализированная <a href="#immutable-binding">неизменяемая привязка</a> для&nbsp;<i>N</i>  уже должна существовать.
	</p>
	<ol><li><p>
		Пусть <i>envRec </i> &ndash; декларативная запись окружения, для которой вызывается этот метод.</p>
		</li>
		<li><p>
		Утверждается: у <i>envRec</i> должна быть неинициализированная <a href="#immutable-binding">неизменяемая привязка</a> для&nbsp;<I>N</I>.</p>
		</li>
		<li><p>
		Присвоить&nbsp;<i>V</i> связанному значению для&nbsp;<i>N</i> в&nbsp;<i>envRec</i>.</p>
		</li>
		<li><p>
		Записать, что <a href="#immutable-binding">неизменяемая привязка</a> для&nbsp;<i>N</i> в&nbsp;<i>envRec</i> была инициализирована.</p>
	</li></ol>
	<h5 id="x10.2.1.2">10.2.1.2 Объектные записи окружения <a href="#x10.2.1.2">#</a> <a href="#x10.2.1.2-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h5>
	<p>
	Каждая объектная запись окружения связана с объектом, который называется её <I>объектом привязки</I> <em><i>binding object</i></em>. Объектная запись окружения содержит набор имён идентификаторов, которые непосредственно соответствуют именам свойств её объекта привязки. Имена свойств, которые не представляют собой <I>IdentifierName</I> <tt>Имя идентификатора</tt>, не входят в этот набор связанных идентификаторов. В этот набор входят как собственные, так и наследуемые свойства, независимо от установок их атрибута [[Enumerable]]. Поскольку свойства могут динамически добавляться к объектам и удаляться из них, теоретически возможно изменение набора идентификаторов, связанных объектной записью окружения, в результате побочного эффекта какой-либо операции, в процессе которой происходит добавление или удаление свойств. Привязки, создаваемые в результате такого побочного эффекта, считаются изменяемыми привязками, даже если атрибут Writable соответствующего свойства имеет значение&nbsp;<b>false</b>. Неизменяемых привязок для объектных записей окружения не существует.</p>
	<p>
	Объектные записи окружения могут быть сконфигурированы таким образом, чтобы предоставлять свой объект привязки в качестве  значения this при вызове функции. Эта возможность используется для задания поведения привязок, порожденных инструкцией With&nbsp;(<a href="x12.html#x12.10">12.10</a>). Данная возможность контролируется булевым значением <i>provideThis</i> <tt>задать This</tt>, которое ассоциируется с каждой объектной записью окружения.  По умолчанию значение <i>provideThis</i> для любой объектной записи окружения &ndash; <b>false</b>.</p>
	<p>
	Поведение конкретных методов спецификации для объектных записей окружения определяется следующими алгоритмами:</p>
	<h6 id="x10.2.1.2.1">10.2.1.2.1 HasBinding(N) <a href="#x10.2.1.2.1">#</a> <a href="#x10.2.1.2.1-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>
	<p>
	Конкретный метод записи окружения HasBinding <tt>Имеет привязку</tt> для объектных записей окружения определяет, есть ли у ассоциированного <a href="#x10.2.1.2">объекта привязки</a> свойство, название которого является значением аргумента&nbsp;<i>N</i>:</p>
	<ol><li><p>
		Пусть <i>envRec </i> &ndash; объектная запись окружения, для которой вызывается этот метод.</p>
		</li>
		<li><p>
		Пусть <i>bindings</i> будет <a href="#x10.2.1.2">объектом привязки</a> для <i>envRec</i>.</p>
		</li>
		<li><p>
		Вернуть результат вызова внутреннего метода [[HasProperty]] для <i>bindings</i> с передачей <i>N</i> в качестве имени свойства.</p>
	</li></ol>
	<h6 id="x10.2.1.2.2">10.2.1.2.2 CreateMutableBinding (N, D) <a href="#x10.2.1.2.2">#</a> <a href="#x10.2.1.2.2-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>
	<p>
	Конкретный метод записи окружения CreateMutableBinding <tt>Создать изменяемую привязку</tt> для объектных записей окружения создаёт в ассоциированном с записью окружения <a href="#x10.2.1.2">объекте привязки</a> свойство, имя которого является строковым значением, и инициализирует его, присваивая значение&nbsp;<b>undefined</b>. До этого момента в <a href="#x10.2.1.2">объекте привязки</a> не должно существовать свойства с именем&nbsp;<i>N</i>. Если имеется булевый аргумент&nbsp;<i>D</i>, который имеет значение&nbsp;<b>true</b>, то атрибуту [[Configurable]] созданного нового свойства присваивается значение <b>true</b>, в противном случае ему присваивается значение <b>false</b>.</p>
	<ol><li><p>
		Пусть <i>envRec </i> &ndash; объектная запись окружения, для которой вызывается этот метод.</p>
		</li>
		<li><p>
		Пусть <i>bindings</i> будет <a href="#x10.2.1.2">объектом привязки</a> для <i>envRec</i>.</p>
		</li>
		<li><p>
		Утверждается: Результат вызова внутреннего метода [[HasProperty]] для <I>bindings</I>, с передачей <i>N</i> в качестве имени свойства, составляет <b>false</b>.</p>
		</li>
		<li><p>
		Если D &ndash; <b>true</b>, тогда пусть <i>configValue</i> будет <b>true</b>, в противном случае пусть <i>configValue</i> будет&nbsp;<b>false</b>.</p>
		</li>

		<li><p>
		Вызвать внутренний метод [[DefineOwnProperty]] для <I>bindings</I>, передавая в качестве аргументов <i>N</i>, <a href="x8.html#x8.10">Property Descriptor</a> {[[Value]]:<b>undefined</b>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <i>configValue</i>} и <b>true</b>.</p>
	</li>
</ol>
<h6 id="x10.2.1.2.3">10.2.1.2.3 SetMutableBinding (N,V,S) <a href="#x10.2.1.2.3">#</a> <a href="#x10.2.1.2.3-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>
	<p>
	Конкретный метод записи окружения SetMutableBinding <tt>Установить значение изменяемой привязки</tt> для объектных записей окружения предпринимает попытку присвоить значение аргумента&nbsp;<i>V</i> значению свойства <a href="#x10.2.1.2">объекта привязки</a> (ассоциированного с записью окружения), имя которого является значением аргумента&nbsp;<i>N</i>.  Свойство с именем&nbsp;<i>N</i> уже должно существовать, но если его не существует, или если оно в данный момент не является перезаписываемым, обработка ошибок определяется значением булевого аргумента&nbsp;<i>S</i>.</p>
	<ol><li><p>
		Пусть <i>envRec </i> &ndash; объектная запись окружения, для которой вызывается этот метод.</p>
		</li>
		<li><p>
		Пусть <i>bindings</i> будет <a href="#x10.2.1.2">объектом привязки</a> для <i>envRec</i>.</p>
		</li>
		<li><p>
		Вызвать внутренний метод [[Put]] для <I>bindings </I>с аргументами <i>N</i>, <i>V </i> и <i>S</i>.</p>
	</li></ol>
	<h6 id="x10.2.1.2.4">10.2.1.2.4 GetBindingValue(N,S) <a href="#x10.2.1.2.4">#</a> <a href="#x10.2.1.2.4-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>
	<p>
	Конкретный метод записи окружения GetBindingValue <tt>Получить значение привязки</tt> для объектных записей окружения возвращает значение свойства для своего ассоциированного <a href="#x10.2.1.2">объекта привязки</a>, имя которого представляет собой строковое значение идентификатора аргумента&nbsp;<i>N</i>. Это свойство уже должно существовать, но если его не существует, то результат зависит от значения аргумента&nbsp;<i>S</i>:</p>
	<ol><li><p>
		Пусть <i>envRec </i> &ndash; объектная запись окружения, для которой вызывается этот метод.</p>
		</li>
		<li><p>
		Пусть <i>bindings </i>будет <a href="#x10.2.1.2">объектом привязки</a> для <i>envRec</i>.</p>
		</li>
		<li><p>
		Пусть <I>value</I> <tt>значение</tt> будет результатом вызова внутреннего метода [[HasProperty]] для <i>bindings</i> с передачей <i>N</i> в качестве имени свойства.</p>
		</li>
		<li><p>
		Если <i>value</i> &ndash; <b>false</b>, то</p>
		<ol><li><p>
			Если <i>S</i> &ndash; <b>false</b>, то вернуть значение <b>undefined</b>, в противном случае сгенерировать исключение <b>ReferenceError</b>.</p>
		</li></ol></li>
		<li><p>
		Вернуть результат вызова внутреннего метода [[Get]] для <i>bindings</i> с передачей <i>N</i> в качестве аргумента.</p>
	</li></ol>
	<h6 id="x10.2.1.2.5">10.2.1.2.5 DeleteBinding (N) <a href="#x10.2.1.2.5">#</a> <a href="#x10.2.1.2.5-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>
	<p>
	Конкретный метод записи окружения DeleteBinding <tt>Удалить привязку</tt> для объектных записей окружения может удалять только те привязки, которые соответствуют свойствам объекта окружения, у которого атрибут [[Configurable]] имеет значение&nbsp;<b>true</b>.</p>
	<ol><li><p>
		Пусть <i>envRec </i> &ndash; объектная запись окружения, для которой вызывается этот метод.</p>
		</li>
		<li><p>
		Пусть <i>bindings </i>будет <a href="#x10.2.1.2">объектом привязки</a> для <i>envRec</i>.</p>
		</li>
		<li><p>
		Вернуть результат вызова внутреннего метода [[Delete]]  для <i>bindings</i>, передавая в качестве аргументов <i>N и&nbsp;</i><b>false</b>.</p>
	</li></ol>
	<h6 id="x10.2.1.2.6">10.2.1.2.6 ImplicitThisValue() <a href="#x10.2.1.2.6">#</a> <a href="#x10.2.1.2.6-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h6>
	<p>
	В качестве своего значения ImplicitThisValue объектные записи окружения возвращают <B>undefined</B>, кроме случаев, когда их флаг <i>provideThis</i> равен <b>true</b>.</p>
	<ol><li><p>
		Пусть <i>envRec </i> &ndash; объектная запись окружения, для которой вызывается этот метод.</p>
		</li>
		<li><p>
		Если флаг <i>provideThis</i> для <i>envRec</i> составляет <b>true</b>, вернуть <a href="#x10.2.1.2">объект привязки</a> для <i>envRec</i>.</p>
		</li>
		<li><p>
		Иначе вернуть&nbsp;<b>undefined</b>.</p>
	</li></ol>
	<h4 id="x10.2.2">10.2.2 Операции Лексического Окружения <a href="#x10.2.2">#</a> <a href="#x10.2.2-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>
	<p>
	Для работы с лексическими окружениями в данной спецификации используются следующие абстрактные операции:</p>
	<h5 id="x10.2.2.1">10.2.2.1 GetIdentifierReference (lex, name, strict) <a href="#x10.2.2.1">#</a> <a href="#x10.2.2.1-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h5>
	<p>
	При вызове абстрактной операции GetIdentifierReference <tt>Получить ссылку на идентификатор</tt> используются <a href="#x10.2">Лексическое Окружение</a> <i>lex</i>, строка идентификатора <i>name </i>и булев флаг&nbsp;<i>strict. </i>Значением <i>lex </i>может быть&nbsp;<b>null</b>. При вызове этой абстрактной операции выполняются следующие шаги:</p>
	<ol><li><p>
		Если <i>lex</i> имеет значение <b>null</b>, то</p>
		<ol><li><p>
			Вернуть значение типа <a href="x8.html#x8.7">Reference</a> со значением базы <b>undefined</b>, с именем ссылки <i>name</i> и с флагом строгого режима&nbsp;<i>strict</i>.</p>
		</li></ol></li>
		<li><p>
		Пусть <i>envRec</i> будет записью окружения <i>lex</i>.</p>
		</li>
		<li><p>
		Пусть <i>exists</i> <tt>существует</tt> будет результатом вызова конкретного метода HasBinding(<i>N</i>) для <i>envRec</i> с передачей <i>name</i> в качестве аргумента&nbsp;<i>N</i>.</p>
		</li>
		<li><p>
		Если <i>exists </i>&ndash; <code><b>true</b></code>, то</p>
		<ol><li><p>
			Вернуть значение типа <a href="x8.html#x8.7">Reference</a> со значением базы <i>envRec</i>, с именем ссылки <i>name</i> и с флагом строгого режима&nbsp;<i>strict</i>.</p>
		</li></ol></li>
		<li><p>
		Иначе</p>
		<ol><li><p>
			Пусть <i>outer</i> <tt>внешний</tt> будет значением <a href="#outer-environment-reference">внешней ссылки окружения</a> для <I>lex</I>.</p>
			</li>
			<li><p>
			Вернуть результат вызова абстрактной операции GetIdentifierReference, передавая в качестве аргументов <i>outer</i>, <i>name</i> и <i>strict</i>.</p>
		</li></ol></li></ol>
		<h5 id="x10.2.2.2">10.2.2.2 NewDeclarativeEnvironment (E) <a href="#x10.2.2.2">#</a> <a href="#x10.2.2.2-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h5>
	<p>
	При вызове абстрактной операции NewDeclarativeEnvironment <tt>Новое декларативное окружение</tt> либо с <a href="#x10.2">Лексическим Окружением</a>, либо с <b>null</b> в качестве аргумента <i>E</i> выполняются следующие шаги:</p>
	<ol><li><p>
		Пусть <i>env</i> будет новым <a href="#x10.2">Лексическим Окружением</a>.</p>
		</li>
		<li><p>
		Пусть <i>envRec</i> будет новой <a href="#declarative-environment-record">декларативной записью окружения</a>, не содержащей привязок.</p>
		</li>
		<li><p>
		Записи Окружения для <i>env</i> присвоить&nbsp;<i>envRec</i>.</p>
		</li>
		<li><p>
		Ссылке на внешнее Лексическое Окружение для&nbsp;<i>env</i> присвоить&nbsp;<i>E</i>.</p>
		</li>
		<li><p>
		Вернуть <i>env</i>.</p>
	</li></ol>
	<h5 id="x10.2.2.3">10.2.2.3 NewObjectEnvironment (O, E) <a href="#x10.2.2.3">#</a> <a href="#x10.2.2.3-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h5>
	<p>
	При вызове абстрактной операции NewObjectEnvironment <tt>Новое объектное окружение</tt> с объектом&nbsp;<i>O</i> и <a href="#x10.2">Лексическим Окружением</a> <i>E </i>(или <b>null)</b> в качестве аргаментов выполняются следующие шаги:</p>
	<ol><li><p>
		Пусть <i>env</i> будет новым <a href="#x10.2">Лексическим Окружением</a>.</p>
		</li>
		<li><p>
		Пусть <i>envRec</i> будет новой <a href="#object-environment-record">объектной записью окружения</a>, содержащей <i>O</i> в качестве <a href="#x10.2.1.2">объекта привязки</a>.</p>
		</li>
		<li><p>
		Записи Окружения для <i>env</i> присвоить&nbsp;<i>envRec</i>.</p>
		</li>
		<li><p>
		Ссылке на внешнее Лексическое Окружение для&nbsp;<i>env</i> присвоить&nbsp;<i>E</i>.</p>
		</li>
		<li><p>
		Вернуть <i>env</i>.</p>
	</li></ol>
	<h4 id="x10.2.3">10.2.3 Глобальное окружение <a href="#x10.2.3">#</a> <a href="#x10.2.3-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>
	<p>
	<i>Глобальное окружение </i>представляет собой уникальное <a href="#x10.2">Лексическое Окружение</a>, создаваемое перед выполнением любого кода на ECMAScript. <a href="#x10.2.1">Запись Окружения</a> глобального окружения представляет собой <a href="#object-environment-record">объектную запись окружения</a>, <a href="#x10.2.1.2">объект привязки</a> которой является <a href="x15.1.html#x15.1" class="term-ref">глобальным объектом</a> (<a href="x15.1.html#x15.1">15.1</a>). <a href="#outer-environment-reference">Ссылка на внешнее окружение</a> глобального окружения равна&nbsp;<b>null</b>.</p>
	<p>
	При выполнение кода на ECMAScript к <a href="x15.1.html#x15.1" class="term-ref">глобальному объекту</a> могут добавляться дополнительные свойства, а исходные свойства могут изменяться.

	</p>
	<h3 id="x10.3">10.3 Контексты исполнения <a href="#x10.3">#</a> <a href="#x10.3-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h3>
	<p>
	Когда контроль переходит к исполняемому коду на ECMAScript, управление вступает в <i>контекст исполнения</i>. Активные контексты исполнения логически образуют стек. Контекст исполнения, находящийся наверху этого логического стека, является активным контекстом исполнения. Всякий раз при переходе управления от исполняемого кода, ассоциированного с текущим контекстом исполнения, к исполняемому коду, не ассоциированному с этим контекстом исполнения, создаётся новый контекст исполнения. Этот вновь созданный контекст исполнения помещается наверх стека и становится активным контекстом исполнения.</p>
	<p>
	Всякий контекст исполнения содержит то состояние, которое необходимо для отслеживания процесса исполнения ассоциированного кода. Кроме того, каждый контекст исполнения имеет компоненты состояния, перечисленные в Таблице&nbsp;19.</p>
	<center>
		<table width="690" border="1" bordercolor="#000000" cellpadding="8" cellspacing="0" rules="ROWS"><caption>Таблица 19. Компоненты состояния контекста исполнения.</caption>
			<colgroup><col width="161"><col width="495"></colgroup><tbody><tr valign="TOP"><td width="161" height="11" bgcolor="#c0c0c0">
					<p>
					<i><b><span class="table-header">Компонент</span></b></i></p>
				</td>
				<td width="495" bgcolor="#c0c0c0">
					<p>
					<i><b><span class="table-header">Назначение</span></b></i></p>
				</td>
			</tr><tr valign="TOP"><td width="161">
					<p>
					LexicalEnvironment</p>
				</td>
				<td width="495">
					<p>
					Определяет <a href="#x10.2">Лексическое Окружение</a>, используемое для разрешения ссылок на идентификаторы, создаваемых кодом в данном контексте исполнения.</p>
				</td>
			</tr><tr valign="TOP"><td width="161">
					<p>
					VariableEnvironment</p>
				</td>
				<td width="495">
					<p>
					Определяет <a href="#x10.2">Лексическое Окружение</a>, в котором запись окружения содержит привязки, создаваемые посредством <i>VariableStatements</i> и <i>FunctionDeclarations</i> в данном контексте исполнения.</p>
				</td>
			</tr><tr valign="TOP"><td width="161">
					<p>ThisBinding</p>
				</td>
				<td width="495">
					<p>Значение, связанное с ключевым словом <code><b>this</b></code> в коде на ECMAScript, ассоциированным с данным контекстом исполнения.</p>
				</td>
			</tr></tbody></table></center>
	<p>
	Компоненты LexicalEnvironment и VariableEnvironment всегда являются <a href="#x10.2">Лексическими Окружениями</a>. При создании контекста исполнения, его компоненты LexicalEnvironment и VariableEnvironment изначально имеют одинаковое значение.  Значение компонента VariableEnvironment никогда не меняется, а   LexicalEnvironment может меняться во время выполнения кода в контексте исполнения.</p>
	<p>
	Чаще всего алгоритмы, представленные в данной спецификации, непосредственно манипулируют только активным контекстом исполнения, расположенным наверху стека контекстов исполнения.  Поэтому, если термины &ldquo;LexicalEnvironment&rdquo;, &ldquo;VariableEnvironment&rdquo; и &ldquo;ThisBinding&rdquo; используются без уточнения, значит, они относятся к компонентам активного контекста исполнения.</p>
	<p>
	Контекст исполнения является исключительно средством для описания, спецификации и не обязан соответствовать конкретным артефактам реализации ECMAScript. Программа на ECMAScript не может осуществлять прямой доступ к контексту исполнения.
	</p>
	<h4 id="x10.3.1">10.3.1 Разрешение идентификатора <a href="#x10.3.1">#</a> <a href="#x10.3.1-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>
	<p>
	Разрешение идентификатора представляет собой процесс определения привязки для <i>Identifier</i> с использованием <a href="#x10.2">Лексического Окружения</a> активного контекста исполнения. Во время выполнения кода на ECMAScript синтаксическое правило <i>PrimaryExpression</i> <b>:</b> <i>Identifier</i> вычисляется с использованием следующего алгоритма:</p>
	<ol><li><p>
		Пусть <i>env</i> будет <a href="#x10.2">Лексическое Окружение</a> активного контекста исполнения.</p>
		</li>
		<li><p>
		Если синтаксическое правило, вычисление которого производится, содержится в <a href="#x10.1.1" class="term-ref">коде в строгом режиме</a>, то пусть <i>strict</i> будет <b>true</b>, иначе пусть <i>strict</i> будет <b>false</b>.</p>
		</li>
		<li><p>
		Вернуть результат вызова функции <a href="#x10.2.2.1">GetIdentifierReference</a>, передавая в качестве аргументов <i>env</i>, <i>Identifier</i> и<i> strict</i>.</p>
	</li></ol><p>
	Результат вычисления идентификатора всегда имеет значение типа <a href="x8.html#x8.7">Reference</a>, при этом его компонент  имени по ссылке равен строке <i>Identifier</i>.</p>
	<h3 id="x10.4">10.4 Установление контекста исполнения <a href="#x10.4">#</a> <a href="#x10.4-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h3>
	<p>
	Исполнение <a href="#global-code">глобального кода</a> или кода с использованием  функции eval&nbsp;(<a href="x15.1.html#x15.1.2.1">15.1.2.1</a>) устанавливает новый контекст исполнения и входит в него. Каждый вызов функции в коде на ECMAScript&nbsp;(<a href="x13.html#x13.2.1">13.2.1</a>) также устанавливает новый контекст исполнения и входит в него, даже если функция вызывает себя рекурсивно. При каждом возврате производится выход из контекста исполнения. Сгенерированное исключение также может выйти из одного или нескольких контекстов исполнения.</p>
	<p>Когда управление входит в контекст исполнения, устанавливается компонент ThisBinding контекста исполнения, определяются его компоненты VariableEnvironment и начальный LexicalEnvironment, и производится создание привязки для объявлений (<a href="#x10.5">10.5</a>). Способ выполнения этих действий зависит от типа кода, в который входит управление.</p>
	<h4 id="x10.4.1">10.4.1 Вход в глобальный код <a href="#x10.4.1">#</a> <a href="#x10.4.1-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>
	<p>
	При вхождении управления в контекст исполнения <a href="#global-code">глобального кода</a> выполняются следующие шаги:</p>
	<ol><li><p>
		Инициализировать контекст исполнения с использованием <a аhref="#global-code">глобального кода</a>, как описано в пункте&nbsp;<a href="#x10.4.1.1">10.4.1.1</a>.</p>
		</li>
		<li><p>
		Произвести Инстанциирование привязки объявлений, в соответствии с описанием в пункте&nbsp;<a href="#x10.5">10.5</a> с использованием <a href="#global-code">глобального кода</a>.</p>
	</li></ol>
	<h5 id="x10.4.1.1">10.4.1.1 Исходный глобальный контекст исполнения <a href="#x10.4.1.1">#</a> <a href="#x10.4.1.1-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h5>
	<p>
	Для инициализации глобального контекста исполнения для кода&nbsp;<i>C</i> на ECMAScript выполняются следующие шаги:</p>
	<ol><li><p>
		Присвоить VariableEnvironment значение <a href="#x10.2.3">Global Environment</a>.</p>
		</li>
		<li><p>
		Присвоить LexicalEnvironment значение <a href="#x10.2.3">Global Environment</a>.</p>
		</li>
		<li><p>
		Присвоить ThisBinding значение <a href="x15.1.html#x15.1" class="term-ref">глобального объекта</a>.</p>
	</li></ol>
	<h4 id="x10.4.2">10.4.2 Вход в Eval-код <a href="#x10.4.2">#</a> <a href="#x10.4.2-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>
	<p>
	При вхождении управления в контекст исполнения <a href="#eval-code">eval-кода</a> выполняются следующие шаги:</p>
	<ol><li><p>
		Если контекст вызова отсутствует или <a href="#eval-code">eval-код</a> вызывается не посредством прямого вызова&nbsp;(<a href="x15.1.html#x15.1.2.1.1">15.1.2.1.1</a>) функции eval, то</p>
		<ol><li><p>
			Инициализировать контекст исполнения, как если бы он был глобальным контекстом исполнения, используя <a href="#eval-code">eval-код</a> в качестве&nbsp;<i>C</i>, в соответствии с описанием в пункте&nbsp;<a href="#x10.4.1.1">10.4.1.1</a>.</p>
		</li></ol></li>
		<li><p>
		Иначе</p>
		<ol><li><p>
			Присвоить ThisBinding то же значение, что и у ThisBinding  вызывающего контекста исполнения.</p>
			</li>
			<li><p>
			Присвоить LexicalEnvironment такое же значение, что и у <a href="#x10.2">LexicalEnvironment</a> вызывающего контекста исполнения.</p>
			</li>
			<li><p>
			Присвоить VariableEnvironment то же значение, что и у VariableEnvironment вызывающего контекста исполнения.</p>
		</li></ol></li>
		<li><p>
		Если <a href="#eval-code">eval-код</a> представляет собой <a href="#x10.1.1">строгий&nbsp;код</a>, то</p>
		<ol><li><p>
			Путь <i>strictVarEnv</i> <tt>Строгое окружение переменной</tt> будет результатом вызова абстрактной операции <a href="#x10.2.2.2">NewDeclarativeEnvironment</a> с передачей в качестве аргумента&nbsp;LexicalEnvironment.</p>
			</li>
			<li><p>
			Присвоить LexicalEnvironment значение <i>strictVarEnv</i>.</p>
			</li>
			<li><p>
			Присвоить VariableEnvironment значение <i>strictVarEnv</i>.</p>
		</li></ol></li>
		<li><p>
		Произвести Инстанциирование привязки объявления, в соответствии с описанием в пункте&nbsp;<a href="#x10.5">10.5</a> с использованием <a href="#eval-code">eval-кода</a>.</p>
	</li></ol>
	<h5 id="x10.4.2.1">10.4.2.1 Ограничения строгого режима <a href="#x10.4.2.1">#</a> <a href="#x10.4.2.1-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h5>
	<p>
	<a href="#eval-code">Eval-код</a> не может <a href="#x10.5">инстанциировать привязки переменных или привязки функции</a> в окружении переменных вызывающего контекста, вызвавшего eval, если код вызывающего контекста или <a href="#eval-code">eval-код</a> является <a href="#x10.1.1">строгим кодом</a>. Вместо этого такие привязки инстанцируются в новом VariableEnvironment, доступ к которому имеет только <a href="#eval-code">eval-код</a>.</p>

  <h4 id="x10.4.3">10.4.3 Вход в код функции <a href="#x10.4.3">#</a> <a href="#x10.4.3-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h4>
	<p>
	Следующие шаги выполняются, когда управление входит в контекст исполнения <a href="#function-code">кода функции</a>, который содержится в объекте функции&nbsp;<i>F</i>, значения <i>thisArg</i> и <i>argumentsList</i> передаются при вызове:</p>
	<ol><li><p>
		Если <a href="#function-code">код функции</a> представляет собой <a href="#x10.1.1">строгий код</a>, то ThisBinding присвоить значение <i>thisArg</i>&nbsp;<tt>Аргумент this</tt>.</p>
		</li>
		<li><p>
		Иначе, если <i>thisArg</i> &ndash; <b>null</b> или <b>undefined</b>, то ThisBinding присвоить значение <a href="x15.1.html#x15.1" class="term-ref">глобального объекта</a>.</p>
		</li>
		<li><p>
		Иначе, если <a href="x8.html#Type">Тип</a>(<i>thisArg</i>) не объект, то ThisBinding присвоить значение <a href="x9.html#x9.9">ToObject</a>(<i>thisArg</i>).</p>
		</li>
		<li><p>
		Иначе, ThisBinding присвоить значение&nbsp;<i>thisArg</i>.</p>
		</li>
		<li><p>
		Пусть <i>localEnv</i> <tt>Локальное окружение</tt> будет результатом вызова <a href="#x10.2.2.2">NewDeclarativeEnvironment</a> с передачей в качестве аргумента значения внутреннего свойства [[Scope]] для&nbsp;<i>F</i>.</p>
		</li>
		<li><p>
		Присвоить LexicalEnvironment значение <i>localEnv</i>.</p>
		</li>
		<li><p>
		Присвоить VariableEnvironment значение <i>localEnv</i>.</p>
		</li>
		<li><p>
		Пусть <i>code</i> будет значением внутреннего свойства [[Code]] для&nbsp;<i>F</i>.</p>
		</li>
		<li><p>
		Выполнить Инстанциирование привязки объявления, используя <i>code</i> и <i>argumentList</i> для <a href="#function-code">кода функции</a>, в соответствии с описанием в пункте&nbsp;<a href="#x10.5">10.5</a>.</p>
	</li></ol>
	<h3 id="x10.5">10.5 Инстанциирование привязки объявления <a href="#x10.5">#</a> <a href="#x10.5-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h3>
	<p>У каждого контекста исполнения есть ассоциированное VariableEnvironment <tt>Окружение Переменных</tt>. Переменные и функции, объявленные в коде на ECMAScript, выполнение которого производится в контексте исполнения, добавляются в качестве привязок в <a href="#x10.2.1">Запись Окружения</a> этого Окружения переменных. Если речь идет о <a href="#function-code">коде функции</a>, то в качестве привязок в эту <a href="#x10.2.1">Запись Окружения</a> добавляются и параметры.</p>
	<p>От типа кода на ECMAScript, исполняемого контекстом исполнения, зависит, какая <a href="#x10.2.1">Запись Окружения</a> используется для привязки объявления, а также тип объявления. Во всем остальном поведение является типовым. При входе в контекст исполнения привязки создаются в окружении переменных в соответствии с приведенным ниже описанием, при этом используется предоставляемый вызывающим кодом <i>code</i> и, если это <a href="#function-code">код функции</a>, <a href="x8.html#x8.8">Список</a> аргументов&nbsp;<i>args</i>:</p>
	<ol><li value="1"><p>
		Пусть <i>env</i> будет компонентом <a href="#x10.2">записи  окружения</a> для VariableEnvironment активного контекста исполнения.</p>
		</li>
		<li><p>
		Если <i>code</i> &ndash; <a href="#eval-code">eval-код</a>, то пусть значение <i>configurableBindings</i> <tt>Конфигурируемые привязки</tt> будет <b>true</b>, иначе пусть <i>configurableBindings</i> будет <b>false</b>.</p>
		</li>
		<li><p>
		Если <i>code</i> &ndash; <a href="#x10.1.1" class="term-ref">код в строгом режиме</a>, то пусть значение <i>strict</i> (<I>строгий</I>) будет <b>true</b>, иначе пусть <i>strict</i> будет <b>false</b>.</p>
		</li><li><p>

		Если <i>code </i>&ndash; <a href="#function-code">код функции</a>, то</p>
		<ol><li><p>
			Пусть <i>func </i>будет функцией, внутренний метод [[Call]] которой инициировал выполнение кода <i>code</i>. Пусть <i>names</i> будет значением внутреннего метода [[FormalParameters]] для <I>func</I>.
			</p>
			</li>
			<li><p>
			Пусть <i>argCount</i> будет количеством элементов в <i>args</i>.</p>
			</li>
			<li><p>
			Пусть <i>n</i> будет числом&nbsp;0.</p>
			</li>
			<li><p>
			Для каждой строки <i>argName</i> в <i>names</i> по порядку списка выполняется следующее:</p>
			<ol><li><p>
				Пусть <i>n</i> будет текущим значением <i>n</i> плюс&nbsp;1.</p>
				</li>
				<li><p>
				Если <i>n</i> больше чем <i>argCount</i>, пусть <i>v</i> будет <b>undefined</b>, в противном случае пусть <i>v</i> будет значением <i>n</i>-нного элемента в <i>args</i>.</p>
				</li>
				<li><p>
				Пусть <i>argAlreadyDeclared</i> <tt>Аргумент уже объявлен</tt> будет результатом вызова конкретного метода HasBinding для <i>env</i>, с передачей в качестве аргумента <i>argName</i>.</p>
				</li>
				<li><p>
				Если <i>argAlreadyDeclared </i>&ndash; <b>false</b>, то вызвать конкретный метод CreateMutableBinding для <I>env</I>, с передачей в качестве аргумента <i>argName</i>.</p>
				</li>
				<li><p>
				Вызвать конкретный метод SetMutableBinding для <i>env</i>, передавая в качестве аргументов <i>argName</i>, <i>v</i> и <i>strict</i>.</p>
			</li></ol></li></ol></li></ol><ol start="5"><li><p>
		Для каждого <i><a href="x13.html#x13">FunctionDeclaration</a>&nbsp;f</i>  в <i>code</i>, по порядку исходного текста выполняется следующее:</p>
		<ol><li><p>Пусть <i>fn</i> будет <i>Identifier</i> в <i><a href="x13.html#x13">FunctionDeclaration</a></i>&nbsp;<i>f.</i></p>
			</li><li><p>Пусть <i>fo</i> будет результатом инстанциирования <i>FunctionDeclaration f</i>, в соответствии в описанием приведенным в&nbsp;<a href="x13.html#x13">Главе&nbsp;13</a>.</p>
			</li><li><p>Пусть <i>funcAlreadyDeclared</i> <tt>Функция уже объявлена</tt> будет результатом вызова конкретного метода HasBinding для <i>env</i>, с передачей в качестве аргумента <i>fn</i>.</p>
			</li><li><p>Если <i>funcAlreadyDeclared </i>&ndash; <b>false</b>, то вызвать конкретный метод CreateMutableBinding для <I>env</I>, с передачей в качестве аргументов <i>fn </i>и <I>configurableBindings</I>.</p>
			</li><li><p>Иначе, если <i>env</i> &ndash; компонент <a href="#x10.2">записи окружения</a> глобального окружения, то</p>
			<ol><li><p>Пусть <i>go</i> будет глобальным объектом.</p>
				</li><li><p>Пусть <i>existingProp</i> <tt>Существующее свойство</tt> будет результатом вызова внутреннего метода [[GetProperty]] для <I>go </I>с аргументом&nbsp;<I>fn</I>.</p>
				</li><li><p>Если <i>existingProp </i>.[[Configurable]] &ndash; <b>true</b>, то</p>
				<ol><li><p>Вызвать внутренний метод [[DefineOwnProperty]] для <I>go</I>, передавая в качестве аргументов <I>fn</I>, <a href="x8.html#x8.10">Property Descriptor</a> {[[Value]]:<i>undefined</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <i>configurableBindings</i> } и <b>true</b>.</p>
				</li></ol></li><li><p>Иначе, если IsAccessorDescrptor(<i>existingProp</i>) или <i>existingProp</i> не имеет значений атрибута  {[[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>}, то</p>
				<ol><li><p>Сгенерировать исключение TypeError.</p>
				</li></ol></li></ol></li><li><p>Вызвать конкретный метод SetMutableBinding для <i>env</i>, передавая в качестве аргументов <i>fn</i>, <I>fo </I>и <i>strict</i>.</p>
	</li></ol></li>
</ol><ol start="6"><li><p>
		Пусть <i>argumentsAlreadyDeclared</i> <tt>Аргументы уже объявлены</tt> будет результатом вызова конкретного метода HasBinding для <i>env</i>, с передачей <code><b>&quot;arguments&quot;</b></code> в качестве аргумента.</p>
		</li>
		<li><p>
		Если <i>code</i> &ndash; <a href="#function-code">код функции</a>, и <i>argumentsAlreadyDeclared </i>&ndash; <b>false</b>, то</p>
		<ol><li><p>
			Пусть <i>argsObj </i>будет результатом вызова абстрактной операции CreateArgumentsObject (<a href="#x10.6">10.6</a>) с передачей в качестве аргументов <i>func, names, args,</i> <i>env </i>и <i>strict</i>.</p>
			</li>
			<li><p>
			Если <i>strict </i>&ndash; <b>true</b>, то
			</p>
			<ol><li><p>
				Вызвать конкретный метод <a href="#x10.2.1.1.7">CreateImmutableBinding</a> для <I>env</I>, передавая в качестве аргумента строку &quot;<code><b>arguments</b></code>&quot;.</p>
				</li>
				<li><p>
				Вызвать конкретный метод <a href="#x10.2.1.1.8">InitializeImmutableBinding</a> для <I>env</I>, передавая в качестве аргументов &quot;<code><b>arguments</b></code>&quot; и <i>argsObj</i>.</p>
			</li></ol></li>
			<li><p>
			Иначе</p>
			<ol><li><p>
				Вызвать конкретный метод CreateMutableBinding для <I>env</I>, передавая в качестве аргумента строку &quot;<code><b>arguments</b></code>&quot;.</p>
				</li>
				<li><p>
				Вызвать конкретный метод SetMutableBinding для <i>env</i>, передавая в качестве аргументов &quot;<code><b>arguments</b></code>&quot;, <i>argsObj</i> и <b>false</b>.</p>
			</li></ol></li></ol></li></ol><ol start="8"><li><p>
		Для каждого <i>VariableDeclaration</i> и <i>VariableDeclarationNoIn</i> <i>d </i>в <i>code</i>, по порядку исходного текста выполняется следующее:</p>
		<ol><li><p>
			Пусть <i>dn</i> будет <i>Identifier</i> в <i>d.</i></p>
			</li>
			<li><p>
			Пусть <i>varAlreadyDeclared</i> <tt>Переменная уже объявлена</tt> будет результатом вызова конкретного метода HasBinding для <i>env</i>, с передачей в качестве аргумента <i>dn</i>.</p>
			</li>
			<li><p>
			Если <i>varAlreadyDeclared </i>&ndash; <b>false</b>, то</p>
			<ol><li><p>
				Вызвать конкретный метод CreateMutableBinding для <i>env</i>, передавая в качестве аргументов <I>dn </I>и <i>configurableBindings</i>.</p>
				</li>
				<li><p>
				Вызвать конкретный метод SetMutableBinding для <i>env</i>, передавая в качестве аргументов <i><i>dn</i></i>, <B>undefined </B>и <i>strict</i>.</p>
			</li></ol></li></ol></li></ol>
	<h3 id="x10.6">10.6 Объект аргументов <a href="#x10.6">#</a> <a href="#x10.6-toc" class="bak">&#9417;</a> <b class="erra">&#9402;</b> <b class="rev1">&#9312;</b> <b class="anno">&#9398;</b></h3>
	<p>
	При входе управления в контекст исполнения для <a href="#function-code">кода функции</a> создаётся объект аргументов, за исключением случаев, если (в соответствии с описанием в пункте&nbsp;<a href="#x10.5">10.5</a>) идентификатор <code><b>arguments</b></code> встречается в качестве <i>Identifier</i> в списке <i>FormalParameterList</i> <tt>Список формальных параметров</tt> этой функции, или если он встречается в качестве <i>Identifier</i> для <i>VariableDeclaration</i> или <i><a href="x13.html#x13">FunctionDeclaration</a></i>, содержащихся в <a href="#function-code">коде функции</a>.</p>
	<p>
	Объект аргументов создаётся посредством вызова абстрактной операции CreateArgumentsObject (Созать объект аргументов) с аргументами <i>func</i> &ndash; объектом функции, код которой подлежит выполнению, <i>names</i> &ndash; <a href="x8.html#x8.8">Списком</a>, содержащим имена формальных параметров функции, <i>args </i>&ndash; фактическими параметрами, передаваемыми во внутренний метод [[Call]], <i>env </i>&ndash; окружением переменной для <a href="#function-code">кода функции</a> и <i>strict</i> &ndash; булевым значением, указывающим, верно ли, что <a href="#function-code">код функции</a> &ndash; <a href="#x10.1.1">строгий&nbsp;код</a>. При вызове абстрактной операции CreateArgumentsObject выполняются следующие шаги:</p>
	<ol><li><p>
		Пусть <i>len</i> будет количеством элементов в <i>args</i>.</p>
		</li>
		<li><p>
		Пусть <i>obj </i>будет результатом создания нового объекта ECMAScript.</p>
		</li>
		<li><p>
		Установить все внутренние методы для <i>obj</i> в соответствии с описанием в пункте&nbsp;<a href="x8.html#x8.12">8.12</a>.</p>
		</li>
		<li><p>
		Присвоить внутреннему свойству [[Class]] для <i>obj</i> значение <b>&quot;</b><code><b>Arguments</b></code>&quot;.</p>
		</li>
		<li><p>
		Пусть <i>Object</i> будет стандартным встроенным конструктором объекта&nbsp;(<a href="x15.2.html#x15.2.2">15.2.2</a>).</p>
		</li>
		<li><p>
		Присвоить внутреннему свойству [[Prototype]] для <i>obj</i> значение стандартного  встроенного объекта-прототипа Object&nbsp;(<a href="x15.2.html#x15.2.4">15.2.4</a>).</p>
		</li>
		<li><p>
		Вызвать внутренний метод [[DefineOwnProperty]] для <i>obj</i>, передавая в качестве аргументов <b>&quot;</b><code><b>length</b></code><b>&quot;</b>, <a href="x8.html#x8.10">Property Descriptor</a> {[[Value]]: <i>len</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>true</b>} и <b>false</b>.</p>
		</li>
		<li><p>
		Пусть <i>map </i>будет результатом создания нового объекта, как если бы этот объект был создан выражением  <code><b>new Object()</b></code>, где <code>Object</code> является <a href="x15.2.html#x15.2">стандартным встроенным конструктором с этим именем</a>.</p>
		</li>
		<li><p>
		Пусть <i>mappedNames</i> будет пустой <a href="x8.html#x8.8">Список</a>.</p>
		</li>
		<li><p>
		Пусть <i>indx</i> = <i>len</i>  - 1.</p>
		</li>
		<li><p>
		Повторять до тех пор, пока <i>indx</i> &gt;= 0,
		</p>
		<ol><li><p>
			Пусть <i>val</i> будет элементом <I>args </I>в позиции <I>indx </I>списка, начинающегося с позиции&nbsp;0.</p>
			</li>
			<li><p>
			Вызвать внутренний метод [[DefineOwnProperty]] для <i>obj</i>, передавая в качестве аргументов <a href="x9.html#x9.8">ToString</a>(<i>indx</i>), <a href="x8.html#x8.10">property descriptor</a> {[[Value]]: <i>val</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <b>true</b>} и <b>false</b>.</p>
			</li>
			<li><p>
			Если <i>indx</i> меньше чем количество элементов в <i>names</i>, то</p>
			<ol><li><p>
				Пусть <i>name</i> будет элементом <I>names </I>в позиции <I>indx </I>списка, начинающегося с позиции&nbsp;0.</p>
				</li>
				<li><p>
				Если <i>strict</i> &ndash; <b>false</b>, и <i>name</i> не является элементом <i>mappedNames</i>, то</p>
				<ol><li><p>
					Добавить <i>name</i> в качестве элемента списка <i>mappedNames</i>.</p>
					</li>
					<li><p>
					Пусть <i>g</i> будет результатом вызова абстрактной операции <i><a href="#MakeArgGetter">MakeArgGetter</a></i> с аргументами <i>name</i> и <i>env</i>.</p>
					</li>
					<li><p>
					Пусть <i>p</i> будет результатом вызова абстрактной операции <i><a href="#MakeArgSetter">MakeArgSetter</a></i> с аргументами <i>name</i> и <i>env</i>.</p>
					</li>
					<li><p>
					Вызвать внутренний метод [[DefineOwnProperty]] для <i>map</i>, передавая в качестве аргументов <a href="x9.html#x9.8">ToString</a>(<i>indx</i>), <a href="x8.html#x8.10">Property Descriptor</a> {[[Set]]: <i>p</i>, [[Get]]: <i>g,</i> [[Configurable]]: <b>true</b>} и <b>false</b>.</p>
				</li></ol></li></ol></li>
			<li><p>
			Пусть <i>indx</i> = <i>indx</i> - 1</p>
		</li></ol></li>
		<li><p>
		Если список <i>mappedNames</i> не пуст, то</p>
		<ol><li><p>
			Присвоить внутреннему свойству [[ParameterMap]] для <i>obj</i> значение&nbsp;<i>map</i>.</p>
			</li>
			<li><p>
			Присвоить внутренним методам [[Get]], [[GetOwnProperty]], [[DefineOwnProperty]] и [[Delete]] для <i>obj</i> определения, приведенные ниже.</p>
		</li></ol></li>
		<li><p>
		Если <i>strict </i>&ndash; <b>false</b>, то</p>
		<ol><li><p>
			Вызвать внутренний метод [[DefineOwnProperty]] для <i>obj</i>, передавая в качестве аргументов &quot;<code><b>callee</b></code>&quot;, <a href="x8.html#x8.10">property descriptor</a> {[[Value]]: <i>func</i>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>true</b>} и <b>false</b>.</p>
		</li></ol></li>
		<li><p>
		Иначе, <i>strict</i> является <b>true</b>, поэтому</p>
		<ol><li><p>
			Пусть <i>thrower</i> будет объектом функции [[ThrowTypeError]]&nbsp;(<a href="x13.html#x13.2.3">13.2.3</a>).</p>
			</li>
			<li><p>
			Вызвать внутренний метод [[DefineOwnProperty]] для <i>obj</i> с аргументами <code><b>&quot;caller&quot;</b></code>, PropertyDescriptor {[[Get]]: <i>thrower</i>, [[Set]]: <i>thrower</i>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b>} и <b>false</b>.</p>
			</li>
			<li><p>
			Вызвать внутренний метод [[DefineOwnProperty]] для <i>obj</i> с аргументами <code><b>&quot;callee&quot;</b></code>, PropertyDescriptor {[[Get]]: <i>thrower</i>, [[Set]]: <i>thrower</i>, [[Enumerable]]: <b>false</b>, [[Configurable]]: <b>false</b>} и <b>false</b>.</p>
		</li></ol></li>
		<li><p>
		Вернуть <i>obj</i>.</p>
	</li></ol><p>
	Абстрактная операция <dfn id="MakeArgGetter"><i>MakeArgGetter</i></dfn>, вызываемая со строкой <i>name</i> и <a href="#x10.2">записью окружения</a> <i>env</i>, создаёт объект функции, который при выполнении возвращает значение, привязанное к <i>name</i> в&nbsp;<i>env</i>. Эта абстрактная операция выполняет следующие шаги:</p>
	<ol><li><p>
		Пусль <i>body</i> будет результатом конкатенации строк &quot;<code><b>return</b></code>&quot;, <i>name</i> и &quot;<code><b>;</b></code>&quot;</p>
		</li>
		<li><p>
		Вернуть результат создания объекта функции, как описано в пункте&nbsp;<a href="x13.html#x13.2">13.2</a>, не используя <i>FormalParameterList</i>, используя <i>body</i> в качестве <i><a href="x13.html#x13">FunctionBody</a></i>, <i>env</i> в качестве <i>Scope</i> и <b>true</b> в качестве&nbsp;<i>Strict</i>.</p>
	</li></ol><p>
	Абстрактная операция <dfn id="MakeArgSetter"><i>MakeArgSetter</i></dfn>, вызываемая со строкой <i>name</i> и <a href="#x10.2">записью окружения</a> <i>env</i>, создаёт объект функции, который при выполнении устанавливает значение, привязанное к <i>name</i> в&nbsp;<i>env</i>. Эта абстрактная операция выполняет следующие шаги:</p>
	<ol><li><p>
		Пусть <i>param</i> будет результатом конкатенации строки <i>name </i>со строкой &quot;<code>_arg</code>&quot;</p>
		</li>
		<li><p>
		Пусть <i>body</i> будет строкой <b>&quot;&lt;name&gt; </b><code><b>=</b></code><b>&lt;param&gt;</b><code><b>;</b></code><b>&quot;</b> при этом вместо <b>&lt;name&gt;</b> &ndash; значение <i>name</i>, а вместо <b>&lt;param&gt; </b>&ndash; значение <i>param</i>.</p>
		</li>
		<li><p>
		Вернуть результат создания объекта функции, как описано в пункте&nbsp;<a href="x13.html#x13.2">13.2</a>, используя <a href="x8.html#x8.8">Список</a>, содержащий единичный строковый <i>param </i>в качестве <i>FormalParameterList</i>, <i>body</i> в качестве <i><a href="x13.html#x13">FunctionBody</a></i>, <i>env</i> в качестве <i>Scope</i> и <b>true</b> в качестве&nbsp;<i>Strict</i>.</p>
	</li></ol><p>
	Внутренний метод [[Get]] объекта аргументов для функции не в строгом режиме с формальными параметрами, вызываемый с именем свойства&nbsp;<i>P</i>, выполняет следующие шаги:</p>
	<ol><li><p>
		Пусть <i>map</i> будет значением внутреннего свойства [[ParameterMap]] объекта аргументов.</p>
		</li>
		<li><p>
		Пусть <i>isMapped</i> будет результатом вызова внутреннего метода [[GetOwnProperty]] для <i>map</i> с передачей <i>P</i> в качестве аргумента.</p>
		</li>
		<li><p>
		Если значение <i>isMapped</i> &ndash; <b>undefined</b>, то</p>
		<ol><li><p>
			Пусть <i>v</i> будет результатом вызова внутреннего метода по умолчанию [[Get]] (<a href="x8.html#x8.12.3">8.12.3</a>) для объекта аргументов с передачей <i>P</i> в качестве аргумента.</p>
			</li>
			<li><p>
			 Если <i>P</i> &ndash; <code><b>&quot;caller&quot;</b></code> и <i>v</i> &ndash; объект функции в строгом режиме, сгенерировать исключение&nbsp;<b><a href="x15.11.html#x15.11.6.5" class="term-ref">TypeError</a></b>.</p>
			</li>
			<li><p>
			Вернуть <i><i>v</i></i>.</p>
		</li></ol></li>
		<li><p>
		Иначе, <i>map</i> содержит соответствие формальному параметру для <i>P</i>, поэтому
		</p>
		<ol><li><p>
			Вернуть результат вызова внутреннего метода [[Get]] для <i>map</i> с передачей <i>P</i> в качестве аргумента.</p>
		</li></ol></li></ol><p>
	Внутренний метод [[GetOwnProperty]] объекта аргументов для функции не в строгом режиме с формальными параметрами, вызываемый с именем свойства&nbsp;<i>P</i>, выполняет следующие шаги:</p>
	<ol><li><p>
		Пусть <I>desc</I> будет результатом вызова внутреннего метода по умолчанию [[GetOwnProperty]] (<a href="x8.html#x8.12.1">8.12.1</a>) для объекта аргументов с передачей <i>P</i> в качестве аргумента.</p>
		</li>
		<li><p>
		Если <i>desc &ndash; </i><b>undefined</b>, вернуть <i>desc</i>.</p>
		</li>
		<li><p>
		Пусть <i>map</i> будет значением внутреннего свойства [[ParameterMap]] объекта аргументов.</p>
		</li>
		<li><p>
		Пусть <i>isMapped</i> будет результатом вызова внутреннего метода [[GetOwnProperty]] для <i>map</i> с передачей <i>P</i> в качестве аргумента.</p>
		</li>
		<li><p>
		Если значение <i>isMapped</i> &ndash; не <b>undefined</b>, то</p>
		<ol><li><p>
			Присвоить <i>desc</i>.[[Value]] результат вызова внутреннего метода [[Get]] для <i>map</i>, передавая <i>P</i> в качестве аргумента.</p>
		</li></ol></li>
		<li><p>
		Вернуть <i>desc</i>.
		</p>
	</li></ol><p>
	Внутренний метод [[DefineOwnProperty]] объекта аргументов для функции не в строгом режиме с формальными параметрами, вызываемый с именем свойства <i>P</i>, <a href="x8.html#x8.10">дескриптором свойства</a> <i>Desc</i> и булевым флагом <i>Throw</i>, выполняет следующие шаги:</p>
	<ol><li><p>
		Пусть <i>map</i> будет значением внутреннего свойства [[ParameterMap]] объекта аргументов.</p>
		</li>
		<li><p>
		Пусть <i>isMapped</i> будет результатом вызова внутреннего метода [[GetOwnProperty]] для <i>map</i> с передачей <i>P</i> в качестве аргумента.</p>
		</li>
		<li><p>
		Пусть <I>desc</I> будет результатом вызова внутреннего метода по умолчанию [[GetOwnProperty]] (<a href="x8.html#x8.12.9">8.12.9</a>) для объекта аргументов с передачей <i>P,</i> <i>Desc</i> и <b>false</b> в качестве аргументов.</p>
		</li>
		<li><p>
		Если <i>allowed </i>&ndash; <b>false</b>, то</p>
		<ol><li><p>
			Если <i>Throw </i>&ndash; <b>true</b>, то сгенерировать исключение <b>TypeError</b>, иначе вернуть <b>false</b>.</p>
		</li></ol></li>
		<li><p>
		Если значение <i>isMapped</i> &ndash; не <b>undefined</b>, то</p>
		<ol><li><p>
			Если <a href="x8.html#x8.10.1">IsAccessorDescriptor</a>(<I>Desc</I>) &ndash; <b>true</b>, то</p>
			<ol><li><p>
				Вызвать внутренний метод [[Delete]] для <i>map,</i> передавая в качестве аргументов <i>P</i> и&nbsp;<b>false</b>.</p>
			</li></ol></li>
			<li><p>
			Иначе</p>
			<ol><li><p>
				Если имеется <i>Desc</i>.[[Value]], то</p>
				<ol><li><p>
					Вызвать внутренний метод [[Put]] для <i>map, </i>передавая в качестве аргументов <i>P</i>, <i>Desc</i>.[[Value]] и <i>Throw</i>.</p>
				</li></ol></li>
				<li><p>
				Если имеетс <i>Desc</i>.[[Writable]], и его значение &ndash; <b>false</b>, то</p>
				<ol><li><p>
					Вызвать внутренний метод [[Delete]] для <i>map, </i>передавая в качестве аргументов <i>P </i>и&nbsp;<b>false</b>.</p>
				</li></ol></li></ol></li></ol></li>
		<li><p>
		Вернуть <b>true</b>.</p>
	</li></ol><p>
	Внутренний метод [[Delete]] объекта аргументов для функции не в строгом режиме с формальными параметрами, вызываемый с именем свойства <i>P</i> и булевым флагом <I>Throw</I>, выполняет следующие шаги:</p>
	<ol><li><p>
		Пусть <i>map</i> будет значением внутреннего свойства [[ParameterMap]] объекта аргументов.</p>
		</li>
		<li><p>
		Пусть <i>isMapped</i> будет результатом вызова внутреннего метода [[GetOwnProperty]] для <i>map</i> с передачей <i>P</i> в качестве аргумента.</p>
		</li>
		<li><p>
		Пусть <I>result</I> будет результатом вызова внутреннего метода по умолчанию [[Delete]] (<a href="x8.html#x8.12.7">8.12.7</a>) для объекта аргументов с передачей <i>P</i> и <I>Throw </I>в качестве аргументов.</p>
		</li>
		<li><p>
		Если <i>result</i> &ndash; <b>true</b> и значение <i>isMapped</i> &ndash; не <b>undefined</b>, то</p>
		<ol><li><p>
			Вызвать внутренний метод [[Delete]] для <i>map</i>, передавая в качестве аргументов <i>P</i> и <b>false</b>.</p>
		</li></ol></li>
		<li><p>
		Вернуть <i>result</i>.</p>
	</li></ol><p class="sp"><b>ПРИМЕЧАНИЕ 1</b> Для функций в нестрогом режиме именованные свойства данных индекса массива (определение которого приводится в пункте&nbsp;<a href="x15.4.html#x15.4">15.4</a>) для объекта аргументов, у которого числовые именованные значения меньше, чем число формальных параметров соответствующего объекта функции, изначально разделяют свои значения с соответствующими привязками к аргументу в контексте исполнения этой функции. Это означает, что при изменении свойства изменяется соответствующее значение привязки к аргументу, и наоборот. Это соответствие нарушается, если такое свойство будет удалено и затем переопределено, или если это свойство будет изменено и станет свойством аксессора. Для функций в строгом режиме значения свойств объекта аргументов являются просто копией аргументов, переданных в функцию. Между значениями свойств и значениями формальных параметров нет динамического связывания.</p>
	<p class="sp"><b>ПРИМЕЧАНИЕ 2</b> Объект ParameterMap и значения его свойств используются в качестве инструмента для определения соответствия объекта аргументов привязкам к аргументу. Доступ к объекту ParameterMap и к объектам, представляющим собой значения его свойств, невозможен непосредственно из кода на ECMAScript. Для реализации заданной семантики нет необходимости в том, чтобы реализация на ECMAScript фактически создавала или использовала эти объекты.</p>
	<p class="sp"><b>ПРИМЕЧАНИЕ 3</b> Объекты аргументов для функций в строгом режиме определяют неконфигурируемые свойства аксессора, называемые &quot;<code><b>caller</b></code>&quot; и &quot;<code><b>callee</b></code>&quot;, которые при доступе генерируют исключение <b><a href="x15.11.html#x15.11.6.5" class="term-ref">TypeError</a></b>. Свойство &quot;<code><b>callee</b></code>&quot; имеет более специфичное значение для функций в нестрогом режиме. А свойство &quot;<code><b>caller</b></code>&quot; всегда обеспечивалось некоторыми реализациями ECMAScript  как расширение, зависящее от реализации. Определение этих свойств в строгом режиме существует для гарантии того, что корректные реализации на ECMAScript не будут определять эти свойства каком-либо иным образом.</p>
	</body><script src="anno.js"></script></html>
